/* assets/js/auth.js
   Naveo FSM – Auth helper for NocoDB v2
   ---------------------------------------------------------
   - Looks up users in your NocoDB 'users' table
   - Exposes Auth.login / Auth.logout / Auth.me / Auth.requireRole
   - Stores a minimal session in localStorage
*/

(function (global) {
  "use strict";

  // ======== CONFIG (edit if needed) =========================================
  const NC_BASE_URL = "https://app.nocodb.com";               // NocoDB host
  const USERS_TABLE_ID = "mes51s7dmb2mewm";                   // users table id
  const USERS_FIELDS = [
    "id",
    "email_address",
    "password",
    "user_role",
    "status",
    "phone",
    "last_login",
    "address"
  ];

  // Where we cache the session client-side
  const SESSION_KEY = "naveo_session";

  // ======== TOKEN RESOLUTION =================================================
  function readMetaPAT() {
    const meta = document.querySelector('meta[name="nocodb-pat"]');
    return meta?.content?.trim() || "";
  }
  function resolvePAT() {
    // Priority: localStorage -> meta tag -> (empty)
    return (
      localStorage.getItem("NC_PAT") ||
      readMetaPAT() ||
      ""
    );
  }

  function ensurePAT() {
    const pat = resolvePAT();
    if (!pat) {
      const err = new Error(
        "NocoDB PAT is missing. Set it once with: localStorage.setItem('NC_PAT','<your PAT>')"
      );
      err.code = "NO_PAT";
      throw err;
    }
    return pat;
  }

  // ======== LOW-LEVEL API HELPER ============================================
  async function ncFetch(path, options = {}) {
    const pat = ensurePAT();
    const headers = {
      "Content-Type": "application/json",
      // NocoDB v2 accepts either of these header names; we’ll send both:
      "xc-token": pat,
      "x-api-key": pat,
      ...(options.headers || {})
    };

    const res = await fetch(`${NC_BASE_URL}${path}`, {
      ...options,
      headers
    });

    if (!res.ok) {
      let details = "";
      try {
        const j = await res.json();
        details = j?.message || JSON.stringify(j);
      } catch {
        details = await res.text();
      }
      const err = new Error(`NocoDB error ${res.status}: ${details || res.statusText}`);
      err.status = res.status;
      throw err;
    }
    // Try JSON first, fall back to text
    const contentType = res.headers.get("content-type") || "";
    if (contentType.includes("application/json")) return res.json();
    return res.text();
  }

  // ======== USERS LOOKUP (by email) =========================================
  async function getUserByEmail(email) {
    const where = encodeURIComponent(`(email_address,eq,${JSON.stringify(email)})`);
    const fields = encodeURIComponent(USERS_FIELDS.join(","));
    const url = `/api/v2/tables/${USERS_TABLE_ID}/records?where=${where}&limit=1&fields=${fields}`;
    const data = await ncFetch(url, { method: "GET" });
    const rows = Array.isArray(data?.list) ? data.list : (Array.isArray(data) ? data : []);
    return rows[0] || null;
  }

  async function patchUser(id, payload) {
    return ncFetch(`/api/v2/tables/${USERS_TABLE_ID}/records/${id}`, {
      method: "PATCH",
      body: JSON.stringify(payload)
    });
  }

  // ======== SESSION HELPERS ==================================================
  function saveSession(session) {
    localStorage.setItem(SESSION_KEY, JSON.stringify(session));
  }
  function loadSession() {
    try {
      const raw = localStorage.getItem(SESSION_KEY);
      return raw ? JSON.parse(raw) : null;
    } catch {
      return null;
    }
  }
  function clearSession() {
    localStorage.removeItem(SESSION_KEY);
  }

  // ======== PUBLIC API =======================================================
  const Auth = {
    /**
     * Login by email + password (plain-text comparison as per your table).
     * Returns a session object { id,email,role,status,phone,address }.
     */
    async login(email, password) {
      if (!email || !password) {
        throw new Error("Email and password are required.");
      }

      const user = await getUserByEmail(email.trim().toLowerCase());
      if (!user) {
        const e = new Error("No account found for this email.");
        e.code = "NO_USER";
        throw e;
      }

      // Your current dataset stores plain text passwords.
      // If you later hash passwords, replace this comparison.
      const matches = String(user.password || "") === String(password);
      if (!matches) {
        const e = new Error("Invalid email or password.");
        e.code = "BAD_CREDENTIALS";
        throw e;
      }

      // Enforce status
      const status = (user.status || "").toLowerCase();
      if (status && status !== "active") {
        const e = new Error("Your account is not active. Please contact the administrator.");
        e.code = "INACTIVE";
        throw e;
      }

      // Update last_login (best-effort)
      try {
        await patchUser(user.id, { last_login: new Date().toISOString() });
      } catch {
        // non-fatal
      }

      const session = {
        id: user.id,
        email: user.email_address,
        role: user.user_role || "",
        status: user.status || "",
        phone: user.phone || "",
        address: user.address || ""
      };

      saveSession(session);
      return session;
    },

    /** Return current session (or null). */
    me() {
      return loadSession();
    },

    /** Clear session. */
    logout() {
      clearSession();
    },

    /** Guard that ensures a user is logged in; if not, redirects to login. */
    requireAuth(options = {}) {
      const sess = loadSession();
      if (!sess) {
        const loginUrl = options.loginUrl || "/login.html";
        window.location.href = loginUrl + `?next=${encodeURIComponent(location.pathname + location.search)}`;
        return null;
      }
      return sess;
    },

    /** Guard that ensures a user has one of the required roles. */
    requireRole(roles, options = {}) {
      const sess = this.requireAuth(options);
      if (!sess) return null;
      const ok = (Array.isArray(roles) ? roles : [roles])
        .map(String)
        .map(r => r.toLowerCase())
        .includes(String(sess.role || "").toLowerCase());
      if (!ok) {
        // default: bounce to home
        window.location.href = options.fallback || "/";
        return null;
      }
      return sess;
    },

    /** Utility: get/set PAT at runtime */
    getPAT() {
      return resolvePAT();
    },
    setPAT(token) {
      if (!token) throw new Error("Empty token");
      localStorage.setItem("NC_PAT", token);
      return token;
    }
  };

  // Expose globally
  global.Auth = Auth;

})(window);
